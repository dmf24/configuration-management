### Configuration Management Community Modules Are (usually) an Anti-Pattern

The common practice of using 3rd party modules for configuration management from public repositories like Puppetforge and Chef "Supermarket" and Ansible Galaxy.  While this practice is understandable, there are serious downsides that are often not apparent until too late.  Community modules tend to work against two of the major benefits of using a configuration management system in the first place.  They always undermine the benefits of a centralized configuration repository, and often interfere with defining useful abstractions.

### Undermining the Centralized Configuration Repository.

When you add too many 3rd party modules, your configuration repository is no longer a comprehensive, canonical description of your site's infrastructure.  Each module you add removes part of that site description from your central repository and replaces it with a reference to a generic public repository, usually oriented around one specific program.  Even worse, you are now outsourcing a number of configuration decisions to a 3rd party, which will not have obvious documentation.  Without 3rd party modules, every managed resource in your environment has associated code in the repository, written by a human, for your specific environment, usually with a commit message and maybe even a reference to a business-relevant issue or ticket.

When your configuration relies on a host of 3rd party modules, Instead of a simple find or grep that takes you directly to the relevant configuration directives, one must first determine the relevant module.  Then you have to go find that module's public repository and documentation.  You'll have to read through it, filtering out the vast majority of irrelevant features to find what you're looking for.  If you're lucky it's just some parameter you need to tweak and can be found on the documentation page.  If you're unlucky, it will be something hard-coded into the module that you won't be able to address without making a pull request to the 3rd party or forking the whole thing yourself.  But more on that later, when I discuss about infrastructure as code.  The important part here is that you've had to waste all this time tracking down a simple explanation for why something is the way it is in your environment.  That's one of the main problems centralized configuration management was intended to solve.  Using community modules ruins this feature.

For example, I was implementing a service that wanted to write a service definition file to /etc/consul.  For anyone who doesn't know, consul is a service discovery tool.  You can configure a node to say "I'm serving sandwiches on port 9023."   Other nodes can query consul for sandwiches and consul will respond with all the nodes and ports serving at the moment (as well as possibly other user-defined metadata).  When I tried this on a Puppet-managed node, Puppet deleted the service file that I created.  There was no logic in our master repository for purging `/etc/consul`.  No one on my team had specifically configured puppet to do this.  It turns out this is just the [default behavior for the Consul module](https://github.com/solarkennedy/puppet-consul/blob/4af8f2c56fbaadb9c0d1701f9fd1a17fbc3b14a4/manifests/init.pp#L221) we happened to be using.  Luckily, disabling it is a simple matter of setting a value in puppet.  But it still surprised me.  It seems odd to me that anyone would even bother to use a decentralized tool like Consul if they were already using Puppet to define every service.  If puppet already knows where all the sandwiches are served, puppet can just tell every other client that wants to know.  In fact it can put the information right into the relevant configuration file, eliminating the need for the node to run any queries.  Sure, I can still imagine some scenarios where it might theoretically be useful, but it seems to me that the main reason to use Consul is for the flexibility of dynamically allocated ports.

### Configuration Management Abstractions

Another major selling point of configuration management tools is that you can define useful high-level abstractions for your infrastructure.  You reason about them in simple terms and potentially implement very powerful configuration options.  The problem with community configuration modules is that they rarely do this.  Every so often they solve interesting problems like managing `/etc/hosts` as a collection of resources rather than a single file, but most of the time all they do is add a one-to-one wrapper layer between the configuration management language and the program's native configuration language.  In many cases, there's no abstraction at all.  You are still required to make all the same configuration decisions and edit just as many files, except now you have to do it using the configuration module's defined API instead of the program's native configuration format.  You haven't gained anything substantial over writing your own from scratch, just the minor hassle of writing some generic boilerplate.

And in some cases, this layer is downright obstructive.  The very first time I attempted to use a 3rd party configuration module, I was configuring postfix using chef.  I needed to replicate an existing Qmail configuration, because incoming emails were being processed and routed into a ticketing system.  Among other things, this processing relied on the [recipient delimiter](http://www.postfix.org/postconf.5.html#recipient_delimiter).  The existing configuration used `-`, and this could not be changed as it would break many existing email addresses.  This is a very simple, one-line configuration change to /etc/postfix/main.cf, as you can see from the link above.  However, the public Chef cookbook for postfix at the time hard-coded this value.  It appears that the current Chef postfix cookbook no longer hard-codes this value.  Presumably it can be changed as the main.cf template is now a [single simple loop](https://github.com/chef-cookbooks/postfix/blob/7031d06df016e51f406c6afd85cb4352df1ee472/templates/main.cf.erb)(Puppet's [is the same](https://github.com/camptocamp/puppet-postfix/blob/8688aaf7e2dcc8a5f996cd3b4601a9f2d2b8a111/templates/conffile.erb)).  But neither modules's documentation([Chef](https://github.com/chef-cookbooks/postfix/blob/7031d06df016e51f406c6afd85cb4352df1ee472/README.md), [Puppet](https://github.com/camptocamp/puppet-postfix/blob/8688aaf7e2dcc8a5f996cd3b4601a9f2d2b8a111/README.md) mentions this setting at all.

So, I just rolled my own postfix cookbook.  I set recipient delimiter to the required value on the required hosts along with a comment in the file explaining why it was that way.  Any future system administrator that happened to inspect `/etc/postfix/main.cf` would see the explanation right there in the file.  The simple courtesy of adding comments to a configuration file is made basically impossible using the standard community libraries.



Just as an example of what a useful abstraction might look like: I saw an excellent disaster recovery strategy that relied on centralized configuration management (using cfengine 2).  In order to save money on hardware, the strategy involved re-purposing all of the development hardware for production use.  Since a server stack was clearly defined as an abstraction in the configuration, all that was necessary is that a mirror version of the production stack be maintained in a "dormant" state.  Converting the ever-changing mess of development servers to production-readiness was a matter of setting a single value in the central code repository, which reassigned all the development servers to the dormant stack; and then setting all the development servers to rebuild and rebooting them.  Restoring the development stacks used the same process.  The site's software itself was deployed separately with a robust set of bash scripts.

In theory, a 3rd party configuration module for defining a full-stack 

### If Public Software Libraries are Good, Why Aren't Configuration Modules?



If this sounds like a generic argument against using 3rd party software libraries, you'd be right.  That is what it sounds like.  And sometimes the same logic [does apply to programs and software libraries](https://www.youtube.com/watch?v=oyLBGkS5ICk).  If you need a single feature provided by a large library, the cost of a whole dependency isn't always worth the feature.  But, more importantly, programs are not configuration.  The line of reasoning that justifies using a standard, abstract http library rather than writing an entire network stack from scratch simply to GET a web resource does not apply to configuration.  Software libraries define high-level abstractions for low-level implementation details.  You build new programs by combining old ones.  This is not how configuration works.  Configuration is about adapting the behavior of a program to changing circumstances and different environments.  Configuration exists when there is NOT one good solution to a problem that simply needs a good implementation.

Public configuration modules rarely define new abstractions of low-level details /etc/postfix/main.cf.


You took all the trouble to centralize your configuration, only to decentralize it again except this time to random people on the internet.

outsources configuration decisions to a 3rd party.  Even if these decisions simply replicate default behavior of a program, the human-written rule for that piece of configuration no longer resides in your central repository.  

2.  Infrastructure as code: reasoning about your computing resources with high level abstractions and programming them accordingly rather than being bound by assumptions about individual hosts.

Community modules are inherently at odds with single source of knowledge because you are effectively outsourcing configuration of your infrastructure to a 3rd party.  Your repository is no longer a useful source of information for a system administrator who needs to understand how and why something is configured the way it is.  Instead, it becomes a collection of links to remote 3rd party repositories and documentation along with the relevant parameters.

There is a very real benefit to the single source of knowledge.  When your configuration repository is primarily home grown, it means that every single item in the repository was put there by a human at your company, usually for a good reason, and is associated with a name, a date, a commit message, and maybe even links to relevant issues or tickets for further background.  Tracking down this information is fast and straightforward.  Thus, any given admin when faced with a problem can quickly get up to speed and make informed decisions about new problems and changes.  The declarations and relationships are all there in the repository.

This is lost with 3rd party modules.  Instead of a simple find or grep that takes you directly to the relevant configuration directives, one must first determine the relevant module.  Then you have to go find that module's public repository and documentation.  You'll have to read through it, filtering out the vast majority of irrelevant features to find what you're looking for.  If you're lucky it's just some parameter you need to tweak and can be found on the documentation page.  If you're unlucky, it will be something hard-coded into the module that you won't be able to address without making a pull request to the 3rd party or forking the whole thing yourself.  But more on that later, when I discuss about infrastructure as code.  The important part here is that you've had to waste all this time tracking down a simple explanation for why something is the way it is in your environment.  That's one of the main problems centralized configuration management was intended to solve.  Using community modules ruins this feature.

The only solution to this is to use fewer modules.  Don't use any module without doing a serious analysis on whether the module will save you time in the long run.  Don't do it just because it's "best practice" or from a vague fear and assertion that 

The fundamental problem with community modules for configuration management is that they rarely solve any problems that weren't introduced by configuration management in the first place.  The point of configuration is to customize a program for your specific environment.  3rd party module writers don't know anything about your environment, so they make their modules generic.  This is, in fact, considered a best practice.  As a result, standard puppet module is a wrapper for an application.  Companies like Opscode and Puppet This wrapper provides a set of default configuration values as well as a configuration interface.  Most applications provide this already, especially applications available as OS packages.  They ship with a configuration interface designed for a system administrator and a set of useful defaults.

Puppet and chef modules aren't software libraries.  They aren't saving you hours of re-inventing the wheel.  Of course you don't want to write your own socket library when good ones exist.  Configuration is not about solving problems permanently it's about tweaking and optimizing existing software for your changing environments.

 I ran into this problem with the very first 3rd party chef module I ever tried to use, postfix.  I needed to change the recipient_delimiter, a simple and standard postfix configuration option that for whatever reason the module developers hadn't bothered to implement.  That was in 2012, and as of 2019 that still doesn't appear to be available as an option in the official Chef postfix module.

###
Config management tools are designed to take as input this repository and a collection of environment-specific facts.  It then yields a converged, configured component of your infrastructure. 